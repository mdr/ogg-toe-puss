{"version":3,"sources":["components/ByteTableRowSpec.tsx","components/useShowHexService.tsx","audio/packetExtractor.ts","util/hexUtils.ts","audio/OggPage.ts","util/DataWindow.ts","audio/oggParser.ts","components/Dropzone.tsx","audio/opusParser.ts","components/ByteTableRow.tsx","components/OggPageHeaderTable.tsx","audio/OggOpusCommentHeader.ts","audio/OggOpusIdentificationHeader.ts","components/OggOpusCommentHeaderTable.tsx","components/cellArranger.ts","components/OggOpusIdentificationHeaderTable.tsx","components/Main.tsx","components/OpusTocByteInfo.tsx","components/OggPacketsList.tsx","components/OggPagesTab.tsx","components/BitstreamsTab.tsx","util/networkUtils.ts","audio/LogicalBitstream.ts","components/App.tsx","index.tsx"],"names":["CellInterpretationType","ShowHexServiceContext","React","createContext","showHex","setShowHex","useShowHexService","useContext","ShowHexServiceProvider","children","useState","showHexService","Provider","value","concatenateArrayBuffers","buffers","totalBytes","_","sumBy","buffer","byteLength","array","Uint8Array","offset","set","asHexString","space","Array","from","map","asHexPair","join","n","toString","slice","OggPage","dataWindow","getSegmentSize","segmentIndex","getByte","getSegment","segments","TextDecoder","decode","this","getArrayBufferSlice","headerType","getBigInt64","getInt32","range","numberOfPageSegments","headerSize","i","segmentSize","segment","push","sum","segmentSizes","DataWindow","arrayBuffer","bytes","dataView","getInt16","getUint32","getUint16","getUint8","length","slide","DataView","CodecIdentifier","startsWith","packet","isEqual","Math","min","takeBytes","detectStreamType","stream","packets","firstPacket","Dropzone","onDrop","onDropAccepted","useCallback","acceptedFiles","useDropzone","accept","getRootProps","getInputProps","className","Mode","Bandwidth","Stereo","FrameCount","singleCellInterpretation","label","type","SINGLE","multipleCellInterpretation","labels","MULTIPLE","ByteTable","rows","row","startByte","endByte","cells","cell","width","hex","byte","rowSpec","ByteTableRow","getHex","j","take","rowSpan","colour","colSpan","header","classNames","interpretation","describeHeaderType","page","parts","containsContinuedPacket","isFirstPage","isLastPage","OggPageHeaderTable","rowSpecs","capturePattern","version","granulePosition","bitstreamSerialNumber","pageSequenceNumber","crcChecksum","getPageSegmentLengthRows","chunk","segmentIndices","isOggOpusCommentHeader","OggOpusCommentHeader","vendorStringLength","isOggOpusIdentificationHeader","OggOpusIdentificationHeader","OggOpusCommentHeaderTable","magicSignature","tableWidth","cellsInCurrentRow","spaceUsedInCurrentRow","spaceLeftInCurrentRow","initialCell","restWidth","numberOfFullRows","floor","fullRows","finalCellWidth","finalCell","arrangeCellsIntoRows","vendorString","userCommentListLength","OggOpusIdentificationHeaderTable","channelCount","preSkip","inputSampleRate","outputGain","channelMappingFamily","AppTab","parseTocByte","tocByte","mode","bandwidth","frameMs","frameCount","config","stereo","STEREO","MONO","frameCountCode","SILK","NB","MB","WB","HYBRID","SWB","FB","CELT","Error","ONE_FRAME","TWO_FRAMES_SAME_SIZE","TWO_FRAMES_DIFF_SIZE","ARBITRARY_FRAMES","OpusTocByteInfo","opusToc","isUnknownPacket","OggPacketsList","isOpus","Fragment","href","OggPagesTab","oggPages","opusBitstreamSerialNumbers","pageNumber","setPageNumber","previousOggPages","setPreviousOggPages","oggPage","undefined","segmentsSoFar","isFirstPacket","extractPacketsEntirelyContainedWithinPage","pageSize","onClick","disabled","includes","number","size","SegmentInfo","BitstreamsTab","streams","previousStreams","setPreviousStreams","serialNumber","selectedStreamSerialNumber","setSelectedStreamSerialNumber","find","id","name","checked","onChange","htmlFor","fetchBinaryFile","url","a","fetch","response","blob","isBitstreamOpus","bitstream","some","opusFile","process","Main","setOggPages","bitstreams","setBitstreams","setOpusBitstreamSerialNumbers","OGG_PAGES","tab","setTab","importFile","pages","parseOggPages","packetInfoPerStream","Map","completedLogicalStreams","packetInfo","get","delete","extractBitstreams","filter","useEffect","then","BITSTREAMS","file","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.00daf865.chunk.js","sourcesContent":["export enum CellInterpretationType {\n  SINGLE = 'SINGLE',\n  MULTIPLE = 'MULTIPLE',\n}\n\nexport interface SingleCellInterpretation {\n  type: CellInterpretationType.SINGLE\n  label: string\n}\n\nexport interface MultipleCellInterpretation {\n  type: CellInterpretationType.MULTIPLE\n  labels: string[]\n}\n\nexport type CellInterpretation = SingleCellInterpretation | MultipleCellInterpretation\n\nexport const singleCellInterpretation = (label: string): SingleCellInterpretation => ({\n  type: CellInterpretationType.SINGLE,\n  label,\n})\n\nexport const multipleCellInterpretation = (labels: string[]): MultipleCellInterpretation => ({\n  type: CellInterpretationType.MULTIPLE,\n  labels,\n})\n\nexport interface ByteTableRowSpec {\n  cells: ByteTableCellSpec[]\n}\n\nexport interface ByteTableCellSpec {\n  width: number\n  header?: string\n  interpretation?: CellInterpretation\n  colour: number\n}\n","import React, { ReactNode, useContext, useState } from 'react'\n\nexport interface ShowHexService {\n  showHex: boolean\n\n  setShowHex(show: boolean): void\n}\n\nconst ShowHexServiceContext = React.createContext<ShowHexService>({\n  showHex: false,\n  setShowHex: () => undefined,\n})\n\nexport const useShowHexService = (): ShowHexService => useContext(ShowHexServiceContext)\n\nexport const ShowHexServiceProvider = ({ children }: { children?: ReactNode | undefined }) => {\n  const [showHex, setShowHex] = useState<boolean>(false)\n  const showHexService: ShowHexService = { showHex, setShowHex }\n  return <ShowHexServiceContext.Provider value={showHexService}>{children}</ShowHexServiceContext.Provider>\n}\n","import { BitstreamSerialNumber, OggPage } from './OggPage'\nimport _ from 'lodash'\nimport { LogicalBitstream } from './LogicalBitstream'\n\ninterface PacketInfo {\n  packets: ArrayBuffer[]\n  segmentsSoFar: ArrayBuffer[]\n}\n\nexport const extractBitstreams = (pages: OggPage[]): LogicalBitstream[] => {\n  const packetInfoPerStream = new Map<BitstreamSerialNumber, PacketInfo>()\n  const completedLogicalStreams: LogicalBitstream[] = []\n  for (const page of pages) {\n    if (page.isFirstPage) {\n      packetInfoPerStream.set(page.bitstreamSerialNumber, { packets: [], segmentsSoFar: [] })\n    }\n    const packetInfo = packetInfoPerStream.get(page.bitstreamSerialNumber)\n    if (packetInfo === undefined) {\n      throw Error(`Unexpected page for bitstream with serial number ${page.bitstreamSerialNumber}`)\n    }\n    for (const segment of page.segments) {\n      packetInfo.segmentsSoFar.push(segment)\n      const segmentCompletesPacket = segment.byteLength < 255\n      if (segmentCompletesPacket) {\n        const packet = concatenateArrayBuffers(packetInfo.segmentsSoFar)\n        packetInfo.packets.push(packet)\n        packetInfo.segmentsSoFar.length = 0\n      }\n    }\n    if (page.isLastPage) {\n      completedLogicalStreams.push({ serialNumber: page.bitstreamSerialNumber, packets: packetInfo.packets })\n      packetInfoPerStream.delete(page.bitstreamSerialNumber)\n    }\n  }\n  // Automatically finish any streams that don't have explicit end-of-stream pages\n  for (const [serialNumber, packetInfo] of packetInfoPerStream) {\n    completedLogicalStreams.push({ serialNumber, packets: packetInfo.packets })\n  }\n  return completedLogicalStreams\n}\n\nconst concatenateArrayBuffers = (buffers: ArrayBuffer[]): ArrayBuffer => {\n  const totalBytes = _.sumBy(buffers, (buffer) => buffer.byteLength)\n  const array = new Uint8Array(totalBytes)\n  let offset = 0\n  for (const buffer of buffers) {\n    array.set(new Uint8Array(buffer), offset)\n    offset += buffer.byteLength\n  }\n  return array.buffer\n}\n\nexport const extractPacketsEntirelyContainedWithinPage = (page: OggPage): ArrayBuffer[] => {\n  const packets: ArrayBuffer[] = []\n  const segmentsSoFar: ArrayBuffer[] = []\n  let isFirstPacket = true\n  for (const segment of page.segments) {\n    segmentsSoFar.push(segment)\n    const segmentCompletesPacket = segment.byteLength < 255\n    if (segmentCompletesPacket) {\n      const packet = concatenateArrayBuffers(segmentsSoFar)\n      if (!(page.containsContinuedPacket && isFirstPacket)) {\n        // skip continuation packet\n        packets.push(packet)\n      }\n      segmentsSoFar.length = 0\n      isFirstPacket = false\n    }\n  }\n  return packets\n}\n","export const asHexString = (buffer: ArrayBuffer, space: boolean = false): string =>\n  Array.from(new Uint8Array(buffer))\n    .map(asHexPair)\n    .join(space ? ' ' : '')\n\nexport const asHexPair = (n: number): string => ('0' + n.toString(16)).slice(-2)\n","import _ from 'lodash'\nimport { DataWindow } from '../util/DataWindow'\nimport { asHexString } from '../util/hexUtils'\nimport { Bytes } from '../util/types'\n\nexport type BitstreamSerialNumber = string\n\nexport class OggPage {\n  constructor(readonly dataWindow: DataWindow) {}\n\n  get capturePattern(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(0, 4))\n  }\n\n  get version(): number {\n    return this.dataWindow.getByte(4)\n  }\n\n  private get headerType(): number {\n    return this.dataWindow.getByte(5)\n  }\n\n  get containsContinuedPacket(): boolean {\n    return !!(this.headerType & (1 << 0))\n  }\n\n  get isFirstPage(): boolean {\n    return !!(this.headerType & (1 << 1))\n  }\n\n  get isLastPage(): boolean {\n    return !!(this.headerType & (1 << 2))\n  }\n\n  get granulePosition(): bigint {\n    return this.dataWindow.getBigInt64(6)\n  }\n\n  get bitstreamSerialNumber(): string {\n    return asHexString(this.dataWindow.getArrayBufferSlice(14, 4))\n  }\n\n  get pageSequenceNumber(): number {\n    return this.dataWindow.getInt32(18)\n  }\n\n  get crcChecksum(): string {\n    return asHexString(this.dataWindow.getArrayBufferSlice(22, 4))\n  }\n\n  get numberOfPageSegments(): number {\n    return this.dataWindow.getByte(26)\n  }\n\n  getSegmentSize = (segmentIndex: number): Bytes => this.dataWindow.getByte(27 + segmentIndex)\n\n  get segmentSizes(): Bytes[] {\n    return _.range(this.numberOfPageSegments).map(this.getSegmentSize)\n  }\n\n  get segments(): ArrayBuffer[] {\n    let offset = this.headerSize\n    const segments: ArrayBuffer[] = []\n    for (let i = 0; i < this.numberOfPageSegments; i++) {\n      const segmentSize = this.getSegmentSize(i)\n      const segment = this.dataWindow.getArrayBufferSlice(offset, segmentSize)\n      segments.push(segment)\n      offset += segmentSize\n    }\n    return segments\n  }\n\n  getSegment = (segmentIndex: number): ArrayBuffer => this.segments[segmentIndex]\n\n  get headerSize(): Bytes {\n    return 27 + this.numberOfPageSegments\n  }\n\n  get pageSize(): Bytes {\n    return this.headerSize + _.sum(this.segmentSizes)\n  }\n}\n","export class DataWindow {\n  private readonly bytes: Uint8Array\n  private readonly dataView: DataView\n  private readonly offset: number\n\n  constructor(arrayBuffer: ArrayBuffer, offset: number = 0) {\n    this.bytes = new Uint8Array(arrayBuffer)\n    this.dataView = new DataView(arrayBuffer)\n    this.offset = offset\n  }\n\n  getByte = (offset: number): number => this.bytes[offset + this.offset]\n\n  getBigInt64 = (offset: number): bigint => this.dataView.getBigInt64(offset + this.offset, true)\n\n  getInt16 = (offset: number): number => this.dataView.getInt16(offset + this.offset, true)\n\n  getInt32 = (offset: number): number => this.dataView.getInt32(offset + this.offset, true)\n\n  getUint32 = (offset: number): number => this.dataView.getUint32(offset + this.offset, true)\n\n  getUint16 = (offset: number): number => this.dataView.getUint16(offset + this.offset, true)\n\n  getUint8 = (offset: number): number => this.dataView.getUint8(offset + this.offset)\n\n  getArrayBufferSlice = (offset: number, length: number): ArrayBuffer =>\n    this.bytes.slice(this.offset + offset, this.offset + offset + length).buffer\n\n  slide = (offset: number): DataWindow => new DataWindow(this.bytes.buffer, this.offset + offset)\n}\n","import { OggPage } from './OggPage'\nimport { DataWindow } from '../util/DataWindow'\nimport { Option } from '../util/util'\nimport _ from 'lodash'\nimport { LogicalBitstream } from './LogicalBitstream'\n\nexport const parseOggPages = (arrayBuffer: ArrayBuffer): OggPage[] => {\n  let dataWindow = new DataWindow(arrayBuffer)\n  let page = new OggPage(dataWindow)\n  const pages = [page]\n  while (!page.isLastPage) {\n    dataWindow = dataWindow.slide(page.pageSize)\n    page = new OggPage(dataWindow)\n    pages.push(page)\n  }\n  return pages\n}\n\nconst CodecIdentifier = {\n  Opus: [0x4f, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], // 'OpusHead'\n  Theora: [0x80, 0x74, 0x68, 0x65, 0x6f, 0x72, 0x61], // '\\x80theora'\n  Vorbis: [0x01, 0x76, 0x6f, 0x72, 0x62, 0x69, 0x73], // '\\x01vorbis'\n  OggSkeleton: [0x66, 0x69, 0x73, 0x68, 0x65, 0x61, 0x64, 0x00], // 'fishead\\0'\n}\n\nconst takeBytes = (packet: ArrayBuffer, n: number): number[] =>\n  Array.from(new Uint8Array(packet.slice(0, Math.min(n, packet.byteLength))))\n\nconst startsWith = (packet: ArrayBuffer, bytes: number[]): boolean => _.isEqual(takeBytes(packet, bytes.length), bytes)\n\nexport const detectStreamType = (stream: LogicalBitstream): Option<string> => {\n  if (stream.packets.length === 0) {\n    return undefined\n  }\n  const firstPacket = stream.packets[0]\n  if (startsWith(firstPacket, CodecIdentifier.Opus)) return 'opus'\n  if (startsWith(firstPacket, CodecIdentifier.Theora)) return 'theora'\n  if (startsWith(firstPacket, CodecIdentifier.Vorbis)) return 'vorbis'\n  if (startsWith(firstPacket, CodecIdentifier.OggSkeleton)) return 'ogg-skeleton'\n  return undefined\n}\n","import React, { useCallback } from 'react'\nimport { useDropzone } from 'react-dropzone'\n\nexport interface DropzoneProps {\n  onDrop(file: File): void\n}\n\nexport const Dropzone = ({ onDrop }: DropzoneProps) => {\n  const onDropAccepted = useCallback((acceptedFiles: File[]) => onDrop(acceptedFiles[0]), [onDrop])\n  const { getRootProps, getInputProps } = useDropzone({\n    onDropAccepted,\n    accept: ['audio/ogg', 'video/ogg', 'application/ogg', 'audio/opus'],\n  })\n\n  return (\n    <div className=\"dropzone\" {...getRootProps()}>\n      <input {...getInputProps()} />\n      Click here or drop an Ogg file to upload\n    </div>\n  )\n}\n","export enum Mode {\n  SILK = 'SILK-only',\n  HYBRID = 'Hybrid',\n  CELT = 'CELT-only',\n}\n\nexport enum Bandwidth {\n  NB = 'NB',\n  MB = '<B>',\n  WB = 'WB',\n  SWB = 'SWB',\n  FB = 'FB',\n}\n\nexport enum Stereo {\n  MONO = 'Mono',\n  STEREO = 'Stereo',\n}\n\nexport enum FrameCount {\n  ONE_FRAME = '1 frame',\n  TWO_FRAMES_SAME_SIZE = '2 frames, equal size',\n  TWO_FRAMES_DIFF_SIZE = '2 frames, different sizes',\n  ARBITRARY_FRAMES = 'Arbitrary number of frames',\n}\n\nexport interface OpusToc {\n  mode: Mode\n  bandwidth: Bandwidth\n  frameMs: number\n  stereo: Stereo\n  frameCount: FrameCount\n}\n\nexport const parseTocByte = (tocByte: number): OpusToc => {\n  const config = (tocByte >> 3) & 0x1f\n  const stereo = (tocByte >> 2) & 0x01 ? Stereo.STEREO : Stereo.MONO\n  const frameCountCode = tocByte & 0x03\n\n  let mode: Mode\n  let bandwidth: Bandwidth\n  let frameMs: number\n\n  switch (true) {\n    case config >= 0 && config <= 3:\n      mode = Mode.SILK\n      bandwidth = Bandwidth.NB\n      frameMs = [10, 20, 40, 60][config % 4]\n      break\n    case config >= 4 && config <= 7:\n      mode = Mode.SILK\n      bandwidth = Bandwidth.MB\n      frameMs = [10, 20, 40, 60][config % 4]\n      break\n    case config >= 8 && config <= 11:\n      mode = Mode.SILK\n      bandwidth = Bandwidth.WB\n      frameMs = [10, 20, 40, 60][config % 4]\n      break\n    case config >= 12 && config <= 13:\n      mode = Mode.HYBRID\n      bandwidth = Bandwidth.SWB\n      frameMs = [10, 20][config % 2]\n      break\n    case config >= 14 && config <= 15:\n      mode = Mode.HYBRID\n      bandwidth = Bandwidth.FB\n      frameMs = [10, 20][config % 2]\n      break\n    case config >= 16 && config <= 19:\n      mode = Mode.CELT\n      bandwidth = Bandwidth.NB\n      frameMs = [2.5, 5, 10, 20][config % 4]\n      break\n    case config >= 20 && config <= 23:\n      mode = Mode.CELT\n      bandwidth = Bandwidth.WB\n      frameMs = [2.5, 5, 10, 20][config % 4]\n      break\n    case config >= 24 && config <= 27:\n      mode = Mode.CELT\n      bandwidth = Bandwidth.SWB\n      frameMs = [2.5, 5, 10, 20][config % 4]\n      break\n    case config >= 28 && config <= 31:\n      mode = Mode.CELT\n      bandwidth = Bandwidth.FB\n      frameMs = [2.5, 5, 10, 20][config % 4]\n      break\n    default:\n      throw new Error('Invalid configuration.')\n  }\n\n  let frameCount: FrameCount\n\n  switch (frameCountCode) {\n    case 0:\n      frameCount = FrameCount.ONE_FRAME\n      break\n    case 1:\n      frameCount = FrameCount.TWO_FRAMES_SAME_SIZE\n      break\n    case 2:\n      frameCount = FrameCount.TWO_FRAMES_DIFF_SIZE\n      break\n    case 3:\n      frameCount = FrameCount.ARBITRARY_FRAMES\n      break\n    default:\n      throw new Error('Invalid frame count code.')\n  }\n\n  return { mode, bandwidth, frameMs, stereo, frameCount }\n}\n","import classNames from 'classnames'\nimport _ from 'lodash'\nimport { DataWindow } from '../util/DataWindow'\nimport { asHexPair } from '../util/hexUtils'\nimport { Bytes } from '../util/types'\nimport { ByteTableRowSpec, CellInterpretationType } from './ByteTableRowSpec'\nexport interface ByteTableProps {\n  showHex: boolean\n  rows: ByteTableRowSpec[]\n  dataWindow: DataWindow\n}\n\nconst TableWidth: Bytes = 4\n\nexport const ByteTable = ({ dataWindow, showHex, rows }: ByteTableProps) => (\n  <table className=\"byte-table\">\n    <tbody>\n      {rows.map((row, i) => {\n        const startByte = i * TableWidth\n        const endByte = startByte + _.sumBy(row.cells, (cell) => cell.width) - 1\n        const hex = _.range(startByte, endByte + 1).map((byte) => asHexPair(dataWindow.getByte(byte)))\n        return (\n          <ByteTableRow\n            key={`byte-table-row-${i}`}\n            showHex={showHex}\n            rowSpec={row}\n            startByte={startByte}\n            endByte={endByte}\n            hex={hex}\n          />\n        )\n      })}\n    </tbody>\n  </table>\n)\n\nexport interface ByteTableRowProps {\n  startByte: number\n  endByte: number\n  showHex: boolean\n  rowSpec: ByteTableRowSpec\n  hex: string[]\n}\n\nexport const ByteTableRow = ({ startByte, endByte, showHex, rowSpec, hex }: ByteTableRowProps) => {\n  const { cells } = rowSpec\n  const getHex = (i: number, j: number): string => hex[_.sumBy(_.take(cells, i), (cell) => cell.width) + j]\n  return (\n    <>\n      <tr>\n        <th className=\"byte-table__byte-header-cell\" rowSpan={showHex ? 3 : 2}>\n          {startByte}-{endByte}\n        </th>\n        {cells.map((cell, i) => (\n          <td\n            key={`byte-table-header-row-${i}`}\n            className={`byte-table__header-cell byte-table__cell-style-${cell.colour} byte-table__border-right`}\n            colSpan={cell.width}\n          >\n            {cell.header ?? <>&nbsp;</>}\n          </td>\n        ))}\n      </tr>\n      {showHex && (\n        <tr>\n          {cells.map((cell, i) =>\n            _.range(cell.width).map((j) => (\n              <td\n                key={`byte-table-hex-row-${i}-${j}`}\n                className={classNames('byte-table__hex-cell', `byte-table__cell-style-${cell.colour}`, {\n                  'byte-table__border-right': j === cell.width - 1,\n                })}\n              >\n                {getHex(i, j)}\n              </td>\n            ))\n          )}\n        </tr>\n      )}\n      <tr className=\"byte-table-row3\">\n        {cells.map((cell, i) =>\n          cell.interpretation?.type === CellInterpretationType.MULTIPLE ? (\n            cell.interpretation.labels.map((label, j) => (\n              <td\n                key={`byte-table-interpretation-${i}-${j}`}\n                className={classNames('byte-table__interpretation-cell', `byte-table__cell-style-${cell.colour}`, {\n                  'byte-table__border-right': j === cell.width - 1,\n                })}\n              >\n                {label}\n              </td>\n            ))\n          ) : (\n            <td\n              key={`byte-table-interpretation-${i}`}\n              className={`byte-table__interpretation-cell byte-table__cell-style-${cell.colour} byte-table__border-right`}\n              colSpan={cell.width}\n            >\n              {cell.interpretation?.label ?? <>&nbsp;</>}\n            </td>\n          )\n        )}\n      </tr>\n    </>\n  )\n}\n","import _ from 'lodash'\nimport { OggPage } from '../audio/OggPage'\nimport { ByteTable } from './ByteTableRow'\nimport {\n  ByteTableRowSpec,\n  ByteTableCellSpec,\n  multipleCellInterpretation,\n  singleCellInterpretation,\n} from './ByteTableRowSpec'\nexport interface OggPageTableProps {\n  page: OggPage\n  showHex: boolean\n}\n\nconst describeHeaderType = (page: OggPage): string => {\n  const parts = []\n  page.containsContinuedPacket && parts.push('Contains continued packet')\n  page.isFirstPage && parts.push('First page')\n  page.isLastPage && parts.push('Last page')\n  return parts.join(', ')\n}\n\nexport const OggPageHeaderTable = ({ page, showHex }: OggPageTableProps) => {\n  const rowSpecs: ByteTableRowSpec[] = [\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          header: 'Capture Pattern',\n          interpretation: multipleCellInterpretation(_.range(4).map((i) => page.capturePattern[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 1,\n          colour: 2,\n          header: 'Version',\n          interpretation: singleCellInterpretation(page.version.toString()),\n        },\n        {\n          width: 1,\n          colour: 3,\n          header: 'Header Type',\n          interpretation: singleCellInterpretation(describeHeaderType(page)),\n        },\n        {\n          width: 2,\n          colour: 4,\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 4,\n          header: 'Granule Position',\n          interpretation: singleCellInterpretation(page.granulePosition.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 4,\n        },\n        {\n          width: 2,\n          colour: 5,\n          header: 'Bitstream Serial Number',\n          interpretation: singleCellInterpretation(page.bitstreamSerialNumber),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 5,\n        },\n        {\n          width: 2,\n          colour: 6,\n          header: 'Page Sequence Number',\n          interpretation: singleCellInterpretation(page.pageSequenceNumber.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 6,\n        },\n        {\n          width: 2,\n          colour: 7,\n          header: 'CRC Checksum',\n          interpretation: singleCellInterpretation(page.crcChecksum),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 7,\n        },\n        {\n          width: 1,\n          colour: 8,\n          header: 'Page Segments',\n          interpretation: singleCellInterpretation(page.numberOfPageSegments.toString()),\n        },\n        ...(page.numberOfPageSegments === 0\n          ? []\n          : [\n              {\n                width: 1,\n                colour: 9,\n                header: 'Segment 1 Size',\n                interpretation: singleCellInterpretation(page.getSegmentSize(0).toString()),\n              } as ByteTableCellSpec,\n            ]),\n      ],\n    },\n    ...getPageSegmentLengthRows(page),\n  ]\n  return <ByteTable dataWindow={page.dataWindow} showHex={showHex} rows={rowSpecs} />\n}\n\nconst getPageSegmentLengthRows = (page: OggPage): ByteTableRowSpec[] =>\n  _.chunk(_.range(1, page.numberOfPageSegments), 4).map((segmentIndices) => ({\n    cells: segmentIndices.map((segmentIndex) => ({\n      width: 1,\n      colour: 9,\n      header: `Segment ${segmentIndex + 1} size`,\n      interpretation: singleCellInterpretation(page.getSegmentSize(segmentIndex).toString()),\n    })),\n  }))\n","import { DataWindow } from '../util/DataWindow'\n\nexport const isOggOpusCommentHeader = (packet: ArrayBuffer): boolean => {\n  if (packet.byteLength < 8) {\n    return false\n  }\n  const magicSignature = new TextDecoder().decode(packet.slice(0, 8))\n  return magicSignature === 'OpusTags'\n}\nexport class OggOpusCommentHeader {\n  constructor(readonly dataWindow: DataWindow) {}\n\n  get magicSignature(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(0, 8))\n  }\n\n  get vendorStringLength(): number {\n    return this.dataWindow.getUint32(8)\n  }\n\n  get vendorString(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(12, this.vendorStringLength))\n  }\n\n  get userCommentListLength(): number {\n    return this.dataWindow.getUint32(12 + this.vendorStringLength)\n  }\n}\n","import { DataWindow } from '../util/DataWindow'\n\nexport const isOggOpusIdentificationHeader = (packet: ArrayBuffer): boolean => {\n  if (packet.byteLength < 8) {\n    return false\n  }\n  const magicSignature = new TextDecoder().decode(packet.slice(0, 8))\n  return magicSignature === 'OpusHead'\n}\n\nexport class OggOpusIdentificationHeader {\n  constructor(readonly dataWindow: DataWindow) {}\n\n  get magicSignature(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(0, 8))\n  }\n\n  get version(): number {\n    return this.dataWindow.getUint8(8)\n  }\n\n  get channelCount(): number {\n    return this.dataWindow.getUint8(9)\n  }\n\n  get preSkip(): number {\n    return this.dataWindow.getUint16(10)\n  }\n\n  get inputSampleRate(): number {\n    return this.dataWindow.getUint32(12)\n  }\n\n  get outputGain(): number {\n    return this.dataWindow.getInt16(16)\n  }\n\n  get channelMappingFamily(): number {\n    return this.dataWindow.getUint8(18)\n  }\n}\n","import _ from 'lodash'\nimport { OggOpusCommentHeader } from '../audio/OggOpusCommentHeader'\nimport { ByteTable } from './ByteTableRow'\nimport { ByteTableRowSpec, multipleCellInterpretation, singleCellInterpretation } from './ByteTableRowSpec'\nimport { arrangeCellsIntoRows } from './cellArranger'\n\nexport interface OggOpusCommentHeaderTableProps {\n  header: OggOpusCommentHeader\n  showHex: boolean\n}\n\nexport const OggOpusCommentHeaderTable = ({ header, showHex }: OggOpusCommentHeaderTableProps) => {\n  const rowSpecs: ByteTableRowSpec[] = [\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          header: 'Magic Signature',\n          interpretation: multipleCellInterpretation(_.range(4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          interpretation: multipleCellInterpretation(_.range(4, 4 + 4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    ...arrangeCellsIntoRows(\n      [\n        {\n          width: 4,\n          colour: 2,\n          header: 'Vendor String Length',\n          interpretation: singleCellInterpretation(header.vendorStringLength.toString()),\n        },\n        {\n          width: header.vendorString.length,\n          colour: 3,\n          header: 'Vendor String',\n          interpretation: singleCellInterpretation(header.vendorString),\n        },\n        {\n          width: 4,\n          colour: 4,\n          header: 'User Comment List Length',\n          interpretation: singleCellInterpretation(header.userCommentListLength.toString()),\n        },\n      ],\n      4\n    ),\n  ]\n\n  return <ByteTable dataWindow={header.dataWindow} showHex={showHex} rows={rowSpecs} />\n}\n","import { ByteTableCellSpec, ByteTableRowSpec } from './ByteTableRowSpec'\nimport _ from 'lodash'\n\nexport const arrangeCellsIntoRows = (cells: ByteTableCellSpec[], tableWidth: number): ByteTableRowSpec[] => {\n  const rows: ByteTableRowSpec[] = []\n  const cellsInCurrentRow: ByteTableCellSpec[] = []\n  const spaceUsedInCurrentRow = () => _.sumBy(cellsInCurrentRow, (cell) => cell.width)\n  for (const cell of cells) {\n    const spaceLeftInCurrentRow = tableWidth - spaceUsedInCurrentRow()\n    if (cell.width <= spaceLeftInCurrentRow) {\n      // Can fit in the current row\n      cellsInCurrentRow.push(cell)\n      if (spaceUsedInCurrentRow() === tableWidth) {\n        rows.push({ cells: [...cellsInCurrentRow] })\n        cellsInCurrentRow.length = 0\n      }\n    } else {\n      // Going to have to wrap\n\n      // Initial cell to finish off current row:\n      const initialCell: ByteTableCellSpec = {\n        colour: cell.colour,\n        width: spaceLeftInCurrentRow,\n        header: cell.header,\n        interpretation: cell.interpretation,\n      }\n      cellsInCurrentRow.push(initialCell)\n      rows.push({ cells: [...cellsInCurrentRow] })\n      cellsInCurrentRow.length = 0\n\n      // Full rows:\n      const restWidth = cell.width - initialCell.width\n      const numberOfFullRows = Math.floor(restWidth / tableWidth)\n      const fullRows = _.range(numberOfFullRows).map<ByteTableRowSpec>((_) => ({\n        cells: [\n          {\n            colour: cell.colour,\n            width: tableWidth,\n          },\n        ],\n      }))\n      rows.push(...fullRows)\n\n      // Final cell if needed:\n      const finalCellWidth = restWidth % tableWidth\n      if (finalCellWidth > 0) {\n        const finalCell: ByteTableCellSpec = {\n          colour: cell.colour,\n          width: finalCellWidth,\n        }\n        cellsInCurrentRow.push(finalCell)\n      }\n    }\n  }\n\n  // Add an uncompleted row if needed\n  if (cellsInCurrentRow.length > 0) {\n    rows.push({ cells: [...cellsInCurrentRow] })\n    cellsInCurrentRow.length = 0\n  }\n  return rows\n}\n","import _ from 'lodash'\nimport { OggOpusIdentificationHeader } from '../audio/OggOpusIdentificationHeader'\nimport { ByteTable } from './ByteTableRow'\nimport { ByteTableRowSpec, multipleCellInterpretation, singleCellInterpretation } from './ByteTableRowSpec'\n\nexport interface OggOpusIdentificationHeaderTableProps {\n  header: OggOpusIdentificationHeader\n  showHex: boolean\n}\n\nexport const OggOpusIdentificationHeaderTable = ({ header, showHex }: OggOpusIdentificationHeaderTableProps) => {\n  const rowSpecs: ByteTableRowSpec[] = [\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          header: 'Magic Signature',\n          interpretation: multipleCellInterpretation(_.range(4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          interpretation: multipleCellInterpretation(_.range(4, 4 + 4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 1,\n          colour: 2,\n          header: 'Version',\n          interpretation: singleCellInterpretation(header.version.toString()),\n        },\n        {\n          width: 1,\n          colour: 3,\n          header: 'Channel Count',\n          interpretation: singleCellInterpretation(header.channelCount.toString()),\n        },\n        {\n          width: 2,\n          colour: 4,\n          header: 'Pre-skip',\n          interpretation: singleCellInterpretation(header.preSkip.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 5,\n          header: 'Input Sample Rate',\n          interpretation: singleCellInterpretation(header.inputSampleRate.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 6,\n          header: 'Output Gain',\n          interpretation: singleCellInterpretation(header.outputGain.toString()),\n        },\n        {\n          width: 1,\n          colour: 7,\n          header: 'Mapping Family',\n          interpretation: singleCellInterpretation(header.channelMappingFamily.toString()),\n        },\n      ],\n    },\n  ]\n  return <ByteTable dataWindow={header.dataWindow} showHex={showHex} rows={rowSpecs} />\n}\n","import React, { useEffect, useState } from 'react'\nimport { BitstreamSerialNumber, OggPage } from '../audio/OggPage'\nimport { extractBitstreams } from '../audio/packetExtractor'\nimport { useShowHexService } from './useShowHexService'\nimport { parseOggPages } from '../audio/oggParser'\nimport { Dropzone } from './Dropzone'\nimport { OggPagesTab } from './OggPagesTab'\nimport { BitstreamsTab } from './BitstreamsTab'\nimport { fetchBinaryFile } from '../util/networkUtils'\nimport { isBitstreamOpus, LogicalBitstream } from '../audio/LogicalBitstream'\n\nconst opusFile = `${process.env.PUBLIC_URL}/example_0.opus`\n\nenum AppTab {\n  OGG_PAGES = 'OGG_PAGES',\n  BITSTREAMS = 'BITSTREAMS',\n}\n\nexport const Main = () => {\n  const [oggPages, setOggPages] = useState<OggPage[]>([])\n  const [bitstreams, setBitstreams] = useState<LogicalBitstream[]>([])\n  const [opusBitstreamSerialNumbers, setOpusBitstreamSerialNumbers] = useState<BitstreamSerialNumber[]>([])\n  const [tab, setTab] = useState<AppTab>(AppTab.OGG_PAGES)\n  const { showHex, setShowHex } = useShowHexService()\n  const importFile = (arrayBuffer: ArrayBuffer) => {\n    const oggPages = parseOggPages(arrayBuffer)\n    const bitstreams = extractBitstreams(oggPages)\n    const opusBitstreamSerialNumbers = bitstreams.filter(isBitstreamOpus).map((bitstream) => bitstream.serialNumber)\n    setOggPages(oggPages)\n    setBitstreams(bitstreams)\n    setOpusBitstreamSerialNumbers(opusBitstreamSerialNumbers)\n  }\n  useEffect(() => {\n    fetchBinaryFile(opusFile).then(importFile)\n  }, [])\n  return (\n    <div className=\"app\">\n      <button onClick={() => setTab(AppTab.OGG_PAGES)} disabled={tab === AppTab.OGG_PAGES}>\n        Ogg Pages\n      </button>\n      <button onClick={() => setTab(AppTab.BITSTREAMS)} disabled={tab === AppTab.BITSTREAMS}>\n        Logical Bitstreams\n      </button>\n      <div className=\"show-hex-checkbox\">\n        <label htmlFor=\"showHex\">Show Hex</label>\n        <input id=\"showHex\" onChange={() => setShowHex(!showHex)} checked={showHex} type=\"checkbox\" />\n      </div>\n      <Dropzone onDrop={async (file) => importFile(await file.arrayBuffer())} />\n      {tab === AppTab.OGG_PAGES && (\n        <OggPagesTab oggPages={oggPages} opusBitstreamSerialNumbers={opusBitstreamSerialNumbers} />\n      )}\n      {tab === AppTab.BITSTREAMS && (\n        <BitstreamsTab streams={bitstreams} opusBitstreamSerialNumbers={opusBitstreamSerialNumbers} />\n      )}\n    </div>\n  )\n}\n","import React from 'react'\nimport { OpusToc } from '../audio/opusParser'\n\nexport interface OpusTocByteInfoProps {\n  opusToc: OpusToc\n}\n\nexport const OpusTocByteInfo = ({ opusToc }: OpusTocByteInfoProps) => (\n  <ul>\n    <li>Mode: {opusToc.mode}</li>\n    <li>Bandwidth: {opusToc.bandwidth}</li>\n    <li>Frame size (ms): {opusToc.frameMs}</li>\n    <li>{opusToc.stereo}</li>\n    <li>Frame Count: {opusToc.frameCount}</li>\n  </ul>\n)\n","import React from 'react'\n\nimport './App.scss'\nimport { asHexString } from '../util/hexUtils'\nimport { isOggOpusCommentHeader, OggOpusCommentHeader } from '../audio/OggOpusCommentHeader'\nimport { isOggOpusIdentificationHeader, OggOpusIdentificationHeader } from '../audio/OggOpusIdentificationHeader'\nimport { DataWindow } from '../util/DataWindow'\nimport { OggOpusCommentHeaderTable } from './OggOpusCommentHeaderTable'\nimport { OggOpusIdentificationHeaderTable } from './OggOpusIdentificationHeaderTable'\nimport { parseTocByte } from '../audio/opusParser'\nimport { OpusTocByteInfo } from './OpusTocByteInfo'\n\nexport interface OggPacketsListProps {\n  showHex: boolean\n  packets: ArrayBuffer[]\n  isOpus: boolean\n}\n\nconst isUnknownPacket = (packet: ArrayBuffer): boolean =>\n  !isOggOpusIdentificationHeader(packet) && !isOggOpusCommentHeader(packet)\n\nexport const OggPacketsList = ({ packets, showHex, isOpus }: OggPacketsListProps) => (\n  <>\n    {packets.map((packet, i) => (\n      <React.Fragment key={`packet-${i}`}>\n        {isUnknownPacket(packet) && isOpus && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes) - Opus Packet\n            </h3>\n            <h4>TOC Byte</h4>\n            <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc6716#section-3.1\">\n              RFC 7845 - 5.1. Identification Header\n            </a>\n            <OpusTocByteInfo opusToc={parseTocByte(new DataWindow(packet).getByte(0))} />\n\n            {showHex && (\n              <div className=\"raw-hex\" key={`packet-hex-${i}`}>\n                {asHexString(packet, true)}\n              </div>\n            )}\n          </>\n        )}\n        {isUnknownPacket(packet) && !isOpus && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes)\n            </h3>\n            {showHex && (\n              <div className=\"raw-hex\" key={`packet-hex-${i}`}>\n                {asHexString(packet, true)}\n              </div>\n            )}\n          </>\n        )}\n        {isOggOpusIdentificationHeader(packet) && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes) - Ogg Opus Identification Header\n            </h3>\n            <p>\n              <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc7845#section-5.1\">\n                RFC 7845 - 5.1. Identification Header\n              </a>\n            </p>\n            <OggOpusIdentificationHeaderTable\n              header={new OggOpusIdentificationHeader(new DataWindow(packet))}\n              showHex={showHex}\n            />\n            <p />\n          </>\n        )}\n        {isOggOpusCommentHeader(packet) && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes) - Ogg Opus Comment Header\n            </h3>\n            <p>\n              <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\">\n                RFC 7845 - 5.2. Comment Header\n              </a>\n            </p>\n            <OggOpusCommentHeaderTable header={new OggOpusCommentHeader(new DataWindow(packet))} showHex={showHex} />\n            <p />\n          </>\n        )}\n      </React.Fragment>\n    ))}\n  </>\n)\n","import { useState } from 'react'\n\nimport './App.scss'\nimport { BitstreamSerialNumber, OggPage } from '../audio/OggPage'\nimport { OggPageHeaderTable } from './OggPageHeaderTable'\nimport _ from 'lodash'\nimport { useShowHexService } from './useShowHexService'\nimport { Option } from '../util/util'\nimport { Bytes } from '../util/types'\nimport { asHexString } from '../util/hexUtils'\nimport { extractPacketsEntirelyContainedWithinPage } from '../audio/packetExtractor'\nimport { OggPacketsList } from './OggPacketsList'\n\nexport interface OggPagesTabProps {\n  readonly oggPages: OggPage[]\n  readonly opusBitstreamSerialNumbers: BitstreamSerialNumber[]\n}\n\nexport const OggPagesTab = ({ oggPages, opusBitstreamSerialNumbers }: OggPagesTabProps) => {\n  const { showHex } = useShowHexService()\n  const [pageNumber, setPageNumber] = useState<number>(0)\n  const [previousOggPages, setPreviousOggPages] = useState<OggPage[]>(oggPages)\n  if (previousOggPages !== oggPages) {\n    setPreviousOggPages(oggPages)\n    setPageNumber(0)\n  }\n  const oggPage = pageNumber < oggPages.length ? oggPages[pageNumber] : undefined\n  const packets = oggPage === undefined ? [] : extractPacketsEntirelyContainedWithinPage(oggPage)\n  return (\n    <div className=\"ogg-pages-tab\">\n      <h1>\n        Ogg Page {pageNumber + 1} / {oggPages.length} ({oggPage?.pageSize ?? 0} bytes)\n      </h1>\n      <button onClick={() => setPageNumber(pageNumber - 1)} disabled={pageNumber === 0}>\n        Previous\n      </button>\n      <button onClick={() => setPageNumber(pageNumber + 1)} disabled={pageNumber >= (oggPages?.length ?? 0) - 1}>\n        Next\n      </button>\n      <h2>Ogg Page Header</h2>\n      {oggPage && (\n        <>\n          <p>\n            <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc3533#section-6\">\n              RFC 3533 - 6. The Ogg page format\n            </a>\n          </p>\n          <OggPageHeaderTable page={oggPage} showHex={showHex} />\n          <h2>Ogg Packets</h2>\n          <OggPacketsList\n            packets={packets}\n            showHex={showHex}\n            isOpus={opusBitstreamSerialNumbers.includes(oggPage.bitstreamSerialNumber)}\n          />\n          <h2>Segments</h2>\n          {_.range(0, oggPage.numberOfPageSegments).map((segmentIndex) => (\n            <SegmentInfo\n              key={`segment-${segmentIndex}`}\n              number={segmentIndex + 1}\n              size={oggPage.getSegmentSize(segmentIndex)}\n              hex={showHex ? asHexString(oggPage.getSegment(segmentIndex), true) : undefined}\n            />\n          ))}\n        </>\n      )}\n    </div>\n  )\n}\n\ninterface SegmentInfoProps {\n  number: number\n  size: Bytes\n  hex: Option<string>\n}\n\nconst SegmentInfo = ({ number, size, hex }: SegmentInfoProps) => (\n  <>\n    <h3>\n      Segment {number} ({size} bytes)\n    </h3>\n    {hex && <div className=\"raw-hex\">{hex}</div>}\n  </>\n)\n","import React, { useState } from 'react'\n\nimport './App.scss'\nimport { useShowHexService } from './useShowHexService'\nimport { BitstreamSerialNumber } from '../audio/OggPage'\nimport { detectStreamType } from '../audio/oggParser'\nimport _ from 'lodash'\nimport { OggPacketsList } from './OggPacketsList'\nimport { LogicalBitstream } from '../audio/LogicalBitstream'\n\nexport interface BitstreamsTabProps {\n  streams: LogicalBitstream[]\n  opusBitstreamSerialNumbers: BitstreamSerialNumber[]\n}\n\nexport const BitstreamsTab = ({ streams, opusBitstreamSerialNumbers }: BitstreamsTabProps) => {\n  const { showHex } = useShowHexService()\n  const [previousStreams, setPreviousStreams] = useState<LogicalBitstream[]>(streams)\n  const [selectedStreamSerialNumber, setSelectedStreamSerialNumber] = useState<BitstreamSerialNumber>(\n    streams[0].serialNumber\n  )\n  if (previousStreams !== streams) {\n    setPreviousStreams(streams)\n    setSelectedStreamSerialNumber(streams[0].serialNumber)\n  }\n\n  const stream = streams.find((stream) => stream.serialNumber === selectedStreamSerialNumber)\n  if (stream === undefined) {\n    return <></>\n  }\n  return (\n    <div>\n      <h1>Logical Bitstreams</h1>\n      {streams.map((stream) => (\n        <div key={stream.serialNumber}>\n          <input\n            type=\"radio\"\n            id={stream.serialNumber}\n            name={stream.serialNumber}\n            value={stream.serialNumber}\n            checked={stream.serialNumber === selectedStreamSerialNumber}\n            onChange={() => setSelectedStreamSerialNumber(stream.serialNumber)}\n          />\n          <label htmlFor={stream.serialNumber}>\n            <span className=\"bitstream-serial-number-radio-label\">{stream.serialNumber}</span> -{' '}\n            {detectStreamType(stream)} - {stream.packets.length} packets -{' '}\n            {_.sumBy(stream.packets, (packet) => packet.byteLength)} bytes\n          </label>\n        </div>\n      ))}\n      <h2>Ogg Packets</h2>\n      <OggPacketsList\n        packets={stream.packets}\n        showHex={showHex}\n        isOpus={opusBitstreamSerialNumbers.includes(stream.serialNumber)}\n      />\n    </div>\n  )\n}\n","export const fetchBinaryFile = async (url: string): Promise<ArrayBuffer> => {\n  const response = await fetch(url)\n  const blob = await response.blob()\n  return await blob.arrayBuffer()\n}\n","import { BitstreamSerialNumber } from './OggPage'\nimport { isOggOpusIdentificationHeader } from './OggOpusIdentificationHeader'\n\nexport interface LogicalBitstream {\n  readonly serialNumber: BitstreamSerialNumber\n  readonly packets: ArrayBuffer[]\n}\n\nexport const isBitstreamOpus = (bitstream: LogicalBitstream): boolean =>\n  bitstream.packets.some((packet) => isOggOpusIdentificationHeader(packet))\n","import React from 'react'\n\nimport './App.scss'\nimport { ShowHexServiceProvider } from './useShowHexService'\nimport { Main } from './Main'\n\nexport const App = () => (\n  <ShowHexServiceProvider>\n    <Main />\n  </ShowHexServiceProvider>\n)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { App } from './components/App'\nimport './index.css'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}