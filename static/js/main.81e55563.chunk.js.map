{"version":3,"sources":["components/ByteTableRowSpec.tsx","components/useShowHexService.tsx","audio/packetExtractor.ts","util/hexUtils.ts","audio/OggPage.ts","util/DataWindow.ts","audio/oggParser.ts","components/Dropzone.tsx","components/Main.tsx","components/ByteTableRow.tsx","components/OggPageHeaderTable.tsx","audio/OggOpusCommentHeader.ts","audio/OggOpusIdentificationHeader.ts","components/OggOpusCommentHeaderTable.tsx","components/cellArranger.ts","components/OggOpusIdentificationHeaderTable.tsx","components/OggPacketsList.tsx","components/OggPagesTab.tsx","components/BitstreamsTab.tsx","util/networkUtils.ts","audio/LogicalBitstream.ts","components/App.tsx","index.tsx"],"names":["CellInterpretationType","ShowHexServiceContext","React","createContext","showHex","setShowHex","useShowHexService","useContext","ShowHexServiceProvider","children","useState","showHexService","Provider","value","concatenateArrayBuffers","buffers","totalBytes","_","sumBy","buffer","byteLength","array","Uint8Array","offset","set","asHexString","space","Array","from","map","asHexPair","join","n","toString","slice","OggPage","dataWindow","getSegmentSize","segmentIndex","getByte","getSegment","segments","TextDecoder","decode","this","getArrayBufferSlice","headerType","getBigInt64","getInt32","range","numberOfPageSegments","headerSize","i","segmentSize","segment","push","sum","segmentSizes","DataWindow","arrayBuffer","bytes","dataView","getInt16","getUint32","getUint16","getUint8","length","slide","DataView","CodecIdentifier","startsWith","packet","isEqual","Math","min","takeBytes","detectStreamType","stream","packets","firstPacket","Dropzone","onDrop","onDropAccepted","useCallback","acceptedFiles","useDropzone","accept","getRootProps","getInputProps","className","AppTab","singleCellInterpretation","label","type","SINGLE","multipleCellInterpretation","labels","MULTIPLE","ByteTable","rows","row","startByte","endByte","cells","cell","width","hex","byte","rowSpec","ByteTableRow","getHex","j","take","rowSpan","colour","colSpan","header","classNames","interpretation","describeHeaderType","page","parts","containsContinuedPacket","isFirstPage","isLastPage","OggPageHeaderTable","rowSpecs","capturePattern","version","granulePosition","bitstreamSerialNumber","pageSequenceNumber","crcChecksum","getPageSegmentLengthRows","chunk","segmentIndices","isOggOpusCommentHeader","OggOpusCommentHeader","vendorStringLength","isOggOpusIdentificationHeader","OggOpusIdentificationHeader","OggOpusCommentHeaderTable","magicSignature","tableWidth","cellsInCurrentRow","spaceUsedInCurrentRow","spaceLeftInCurrentRow","initialCell","restWidth","numberOfFullRows","floor","fullRows","finalCellWidth","finalCell","arrangeCellsIntoRows","vendorString","userCommentListLength","OggOpusIdentificationHeaderTable","channelCount","preSkip","inputSampleRate","outputGain","channelMappingFamily","isUnknownPacket","OggPacketsList","isOpus","Fragment","href","OggPagesTab","oggPages","opusBitstreamSerialNumbers","pageNumber","setPageNumber","previousOggPages","setPreviousOggPages","oggPage","undefined","segmentsSoFar","isFirstPacket","extractPacketsEntirelyContainedWithinPage","pageSize","onClick","disabled","includes","number","size","SegmentInfo","BitstreamsTab","streams","previousStreams","setPreviousStreams","serialNumber","selectedStreamSerialNumber","setSelectedStreamSerialNumber","find","id","name","checked","onChange","htmlFor","fetchBinaryFile","url","a","fetch","response","blob","isBitstreamOpus","bitstream","some","opusFile","process","Main","setOggPages","bitstreams","setBitstreams","setOpusBitstreamSerialNumbers","OGG_PAGES","tab","setTab","importFile","pages","parseOggPages","packetInfoPerStream","Map","completedLogicalStreams","packetInfo","get","Error","delete","extractBitstreams","filter","useEffect","then","BITSTREAMS","file","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.81e55563.chunk.js","sourcesContent":["export enum CellInterpretationType {\n  SINGLE = 'SINGLE',\n  MULTIPLE = 'MULTIPLE',\n}\n\nexport interface SingleCellInterpretation {\n  type: CellInterpretationType.SINGLE\n  label: string\n}\n\nexport interface MultipleCellInterpretation {\n  type: CellInterpretationType.MULTIPLE\n  labels: string[]\n}\n\nexport type CellInterpretation = SingleCellInterpretation | MultipleCellInterpretation\n\nexport const singleCellInterpretation = (label: string): SingleCellInterpretation => ({\n  type: CellInterpretationType.SINGLE,\n  label,\n})\n\nexport const multipleCellInterpretation = (labels: string[]): MultipleCellInterpretation => ({\n  type: CellInterpretationType.MULTIPLE,\n  labels,\n})\n\nexport interface ByteTableRowSpec {\n  cells: ByteTableCellSpec[]\n}\n\nexport interface ByteTableCellSpec {\n  width: number\n  header?: string\n  interpretation?: CellInterpretation\n  colour: number\n}\n","import React, { ReactNode, useContext, useState } from 'react'\n\nexport interface ShowHexService {\n  showHex: boolean\n\n  setShowHex(show: boolean): void\n}\n\nconst ShowHexServiceContext = React.createContext<ShowHexService>({\n  showHex: false,\n  setShowHex: () => undefined,\n})\n\nexport const useShowHexService = (): ShowHexService => useContext(ShowHexServiceContext)\n\nexport const ShowHexServiceProvider = ({ children }: { children?: ReactNode | undefined }) => {\n  const [showHex, setShowHex] = useState<boolean>(false)\n  const showHexService: ShowHexService = { showHex, setShowHex }\n  return <ShowHexServiceContext.Provider value={showHexService}>{children}</ShowHexServiceContext.Provider>\n}\n","import { BitstreamSerialNumber, OggPage } from './OggPage'\nimport _ from 'lodash'\nimport { LogicalBitstream } from './LogicalBitstream'\n\ninterface PacketInfo {\n  packets: ArrayBuffer[]\n  segmentsSoFar: ArrayBuffer[]\n}\n\nexport const extractBitstreams = (pages: OggPage[]): LogicalBitstream[] => {\n  const packetInfoPerStream = new Map<BitstreamSerialNumber, PacketInfo>()\n  const completedLogicalStreams: LogicalBitstream[] = []\n  for (const page of pages) {\n    if (page.isFirstPage) {\n      packetInfoPerStream.set(page.bitstreamSerialNumber, { packets: [], segmentsSoFar: [] })\n    }\n    const packetInfo = packetInfoPerStream.get(page.bitstreamSerialNumber)\n    if (packetInfo === undefined) {\n      throw Error(`Unexpected page for bitstream with serial number ${page.bitstreamSerialNumber}`)\n    }\n    for (const segment of page.segments) {\n      packetInfo.segmentsSoFar.push(segment)\n      const segmentCompletesPacket = segment.byteLength < 255\n      if (segmentCompletesPacket) {\n        const packet = concatenateArrayBuffers(packetInfo.segmentsSoFar)\n        packetInfo.packets.push(packet)\n        packetInfo.segmentsSoFar.length = 0\n      }\n    }\n    if (page.isLastPage) {\n      completedLogicalStreams.push({ serialNumber: page.bitstreamSerialNumber, packets: packetInfo.packets })\n      packetInfoPerStream.delete(page.bitstreamSerialNumber)\n    }\n  }\n  // Automatically finish any streams that don't have explicit end-of-stream pages\n  for (const [serialNumber, packetInfo] of packetInfoPerStream) {\n    completedLogicalStreams.push({ serialNumber, packets: packetInfo.packets })\n  }\n  return completedLogicalStreams\n}\n\nconst concatenateArrayBuffers = (buffers: ArrayBuffer[]): ArrayBuffer => {\n  const totalBytes = _.sumBy(buffers, (buffer) => buffer.byteLength)\n  const array = new Uint8Array(totalBytes)\n  let offset = 0\n  for (const buffer of buffers) {\n    array.set(new Uint8Array(buffer), offset)\n    offset += buffer.byteLength\n  }\n  return array.buffer\n}\n\nexport const extractPacketsEntirelyContainedWithinPage = (page: OggPage): ArrayBuffer[] => {\n  const packets: ArrayBuffer[] = []\n  const segmentsSoFar: ArrayBuffer[] = []\n  let isFirstPacket = true\n  for (const segment of page.segments) {\n    segmentsSoFar.push(segment)\n    const segmentCompletesPacket = segment.byteLength < 255\n    if (segmentCompletesPacket) {\n      const packet = concatenateArrayBuffers(segmentsSoFar)\n      if (!(page.containsContinuedPacket && isFirstPacket)) {\n        // skip continuation packet\n        packets.push(packet)\n      }\n      segmentsSoFar.length = 0\n      isFirstPacket = false\n    }\n  }\n  return packets\n}\n","export const asHexString = (buffer: ArrayBuffer, space: boolean = false): string =>\n  Array.from(new Uint8Array(buffer))\n    .map(asHexPair)\n    .join(space ? ' ' : '')\n\nexport const asHexPair = (n: number): string => ('0' + n.toString(16)).slice(-2)\n","import _ from 'lodash'\nimport { DataWindow } from '../util/DataWindow'\nimport { asHexString } from '../util/hexUtils'\nimport { Bytes } from '../util/types'\n\nexport type BitstreamSerialNumber = string\n\nexport class OggPage {\n  constructor(readonly dataWindow: DataWindow) {}\n\n  get capturePattern(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(0, 4))\n  }\n\n  get version(): number {\n    return this.dataWindow.getByte(4)\n  }\n\n  private get headerType(): number {\n    return this.dataWindow.getByte(5)\n  }\n\n  get containsContinuedPacket(): boolean {\n    return !!(this.headerType & (1 << 0))\n  }\n\n  get isFirstPage(): boolean {\n    return !!(this.headerType & (1 << 1))\n  }\n\n  get isLastPage(): boolean {\n    return !!(this.headerType & (1 << 2))\n  }\n\n  get granulePosition(): bigint {\n    return this.dataWindow.getBigInt64(6)\n  }\n\n  get bitstreamSerialNumber(): string {\n    return asHexString(this.dataWindow.getArrayBufferSlice(14, 4))\n  }\n\n  get pageSequenceNumber(): number {\n    return this.dataWindow.getInt32(18)\n  }\n\n  get crcChecksum(): string {\n    return asHexString(this.dataWindow.getArrayBufferSlice(22, 4))\n  }\n\n  get numberOfPageSegments(): number {\n    return this.dataWindow.getByte(26)\n  }\n\n  getSegmentSize = (segmentIndex: number): Bytes => this.dataWindow.getByte(27 + segmentIndex)\n\n  get segmentSizes(): Bytes[] {\n    return _.range(this.numberOfPageSegments).map(this.getSegmentSize)\n  }\n\n  get segments(): ArrayBuffer[] {\n    let offset = this.headerSize\n    const segments: ArrayBuffer[] = []\n    for (let i = 0; i < this.numberOfPageSegments; i++) {\n      const segmentSize = this.getSegmentSize(i)\n      const segment = this.dataWindow.getArrayBufferSlice(offset, segmentSize)\n      segments.push(segment)\n      offset += segmentSize\n    }\n    return segments\n  }\n\n  getSegment = (segmentIndex: number): ArrayBuffer => this.segments[segmentIndex]\n\n  get headerSize(): Bytes {\n    return 27 + this.numberOfPageSegments\n  }\n\n  get pageSize(): Bytes {\n    return this.headerSize + _.sum(this.segmentSizes)\n  }\n}\n","export class DataWindow {\n  private readonly bytes: Uint8Array\n  private readonly dataView: DataView\n  private readonly offset: number\n\n  constructor(arrayBuffer: ArrayBuffer, offset: number = 0) {\n    this.bytes = new Uint8Array(arrayBuffer)\n    this.dataView = new DataView(arrayBuffer)\n    this.offset = offset\n  }\n\n  getByte = (offset: number): number => this.bytes[offset + this.offset]\n\n  getBigInt64 = (offset: number): bigint => this.dataView.getBigInt64(offset + this.offset, true)\n\n  getInt16 = (offset: number): number => this.dataView.getInt16(offset + this.offset, true)\n\n  getInt32 = (offset: number): number => this.dataView.getInt32(offset + this.offset, true)\n\n  getUint32 = (offset: number): number => this.dataView.getUint32(offset + this.offset, true)\n\n  getUint16 = (offset: number): number => this.dataView.getUint16(offset + this.offset, true)\n\n  getUint8 = (offset: number): number => this.dataView.getUint8(offset + this.offset)\n\n  getArrayBufferSlice = (offset: number, length: number): ArrayBuffer =>\n    this.bytes.slice(this.offset + offset, this.offset + offset + length).buffer\n\n  slide = (offset: number): DataWindow => new DataWindow(this.bytes.buffer, this.offset + offset)\n}\n","import { OggPage } from './OggPage'\nimport { DataWindow } from '../util/DataWindow'\nimport { Option } from '../util/util'\nimport _ from 'lodash'\nimport { LogicalBitstream } from './LogicalBitstream'\n\nexport const parseOggPages = (arrayBuffer: ArrayBuffer): OggPage[] => {\n  let dataWindow = new DataWindow(arrayBuffer)\n  let page = new OggPage(dataWindow)\n  const pages = [page]\n  while (!page.isLastPage) {\n    dataWindow = dataWindow.slide(page.pageSize)\n    page = new OggPage(dataWindow)\n    pages.push(page)\n  }\n  return pages\n}\n\nconst CodecIdentifier = {\n  Opus: [0x4f, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], // 'OpusHead'\n  Theora: [0x80, 0x74, 0x68, 0x65, 0x6f, 0x72, 0x61], // '\\x80theora'\n  Vorbis: [0x01, 0x76, 0x6f, 0x72, 0x62, 0x69, 0x73], // '\\x01vorbis'\n  OggSkeleton: [0x66, 0x69, 0x73, 0x68, 0x65, 0x61, 0x64, 0x00], // 'fishead\\0'\n}\n\nconst takeBytes = (packet: ArrayBuffer, n: number): number[] =>\n  Array.from(new Uint8Array(packet.slice(0, Math.min(n, packet.byteLength))))\n\nconst startsWith = (packet: ArrayBuffer, bytes: number[]): boolean => _.isEqual(takeBytes(packet, bytes.length), bytes)\n\nexport const detectStreamType = (stream: LogicalBitstream): Option<string> => {\n  if (stream.packets.length === 0) {\n    return undefined\n  }\n  const firstPacket = stream.packets[0]\n  if (startsWith(firstPacket, CodecIdentifier.Opus)) return 'opus'\n  if (startsWith(firstPacket, CodecIdentifier.Theora)) return 'theora'\n  if (startsWith(firstPacket, CodecIdentifier.Vorbis)) return 'vorbis'\n  if (startsWith(firstPacket, CodecIdentifier.OggSkeleton)) return 'ogg-skeleton'\n  return undefined\n}\n","import React, { useCallback } from 'react'\nimport { useDropzone } from 'react-dropzone'\n\nexport interface DropzoneProps {\n  onDrop(file: File): void\n}\n\nexport const Dropzone = ({ onDrop }: DropzoneProps) => {\n  const onDropAccepted = useCallback((acceptedFiles: File[]) => onDrop(acceptedFiles[0]), [onDrop])\n  const { getRootProps, getInputProps } = useDropzone({\n    onDropAccepted,\n    accept: ['audio/ogg', 'video/ogg', 'application/ogg', 'audio/opus'],\n  })\n\n  return (\n    <div className=\"dropzone\" {...getRootProps()}>\n      <input {...getInputProps()} />\n      Click here or drop an Ogg file to upload\n    </div>\n  )\n}\n","import React, { useEffect, useState } from 'react'\nimport { BitstreamSerialNumber, OggPage } from '../audio/OggPage'\nimport { extractBitstreams } from '../audio/packetExtractor'\nimport { useShowHexService } from './useShowHexService'\nimport { parseOggPages } from '../audio/oggParser'\nimport { Dropzone } from './Dropzone'\nimport { OggPagesTab } from './OggPagesTab'\nimport { BitstreamsTab } from './BitstreamsTab'\nimport { fetchBinaryFile } from '../util/networkUtils'\nimport { isBitstreamOpus, LogicalBitstream } from '../audio/LogicalBitstream'\n\nconst opusFile = `${process.env.PUBLIC_URL}/example_0.opus`\n\nenum AppTab {\n  OGG_PAGES = 'OGG_PAGES',\n  BITSTREAMS = 'BITSTREAMS',\n}\n\nexport const Main = () => {\n  const [oggPages, setOggPages] = useState<OggPage[]>([])\n  const [bitstreams, setBitstreams] = useState<LogicalBitstream[]>([])\n  const [opusBitstreamSerialNumbers, setOpusBitstreamSerialNumbers] = useState<BitstreamSerialNumber[]>([])\n  const [tab, setTab] = useState<AppTab>(AppTab.OGG_PAGES)\n  const { showHex, setShowHex } = useShowHexService()\n  const importFile = (arrayBuffer: ArrayBuffer) => {\n    const oggPages = parseOggPages(arrayBuffer)\n    const bitstreams = extractBitstreams(oggPages)\n    const opusBitstreamSerialNumbers = bitstreams.filter(isBitstreamOpus).map((bitstream) => bitstream.serialNumber)\n    setOggPages(oggPages)\n    setBitstreams(bitstreams)\n    setOpusBitstreamSerialNumbers(opusBitstreamSerialNumbers)\n  }\n  useEffect(() => {\n    fetchBinaryFile(opusFile).then(importFile)\n  }, [])\n  return (\n    <div className=\"app\">\n      <button onClick={() => setTab(AppTab.OGG_PAGES)} disabled={tab === AppTab.OGG_PAGES}>\n        Ogg Pages\n      </button>\n      <button onClick={() => setTab(AppTab.BITSTREAMS)} disabled={tab === AppTab.BITSTREAMS}>\n        Logical Bitstreams\n      </button>\n      <div className=\"show-hex-checkbox\">\n        <label htmlFor=\"showHex\">Show Hex</label>\n        <input id=\"showHex\" onChange={() => setShowHex(!showHex)} checked={showHex} type=\"checkbox\" />\n      </div>\n      <Dropzone onDrop={async (file) => importFile(await file.arrayBuffer())} />\n      {tab === AppTab.OGG_PAGES && (\n        <OggPagesTab oggPages={oggPages} opusBitstreamSerialNumbers={opusBitstreamSerialNumbers} />\n      )}\n      {tab === AppTab.BITSTREAMS && (\n        <BitstreamsTab streams={bitstreams} opusBitstreamSerialNumbers={opusBitstreamSerialNumbers} />\n      )}\n    </div>\n  )\n}\n","import classNames from 'classnames'\nimport _ from 'lodash'\nimport { DataWindow } from '../util/DataWindow'\nimport { asHexPair } from '../util/hexUtils'\nimport { Bytes } from '../util/types'\nimport { ByteTableRowSpec, CellInterpretationType } from './ByteTableRowSpec'\nexport interface ByteTableProps {\n  showHex: boolean\n  rows: ByteTableRowSpec[]\n  dataWindow: DataWindow\n}\n\nconst TableWidth: Bytes = 4\n\nexport const ByteTable = ({ dataWindow, showHex, rows }: ByteTableProps) => (\n  <table className=\"byte-table\">\n    <tbody>\n      {rows.map((row, i) => {\n        const startByte = i * TableWidth\n        const endByte = startByte + _.sumBy(row.cells, (cell) => cell.width) - 1\n        const hex = _.range(startByte, endByte + 1).map((byte) => asHexPair(dataWindow.getByte(byte)))\n        return (\n          <ByteTableRow\n            key={`byte-table-row-${i}`}\n            showHex={showHex}\n            rowSpec={row}\n            startByte={startByte}\n            endByte={endByte}\n            hex={hex}\n          />\n        )\n      })}\n    </tbody>\n  </table>\n)\n\nexport interface ByteTableRowProps {\n  startByte: number\n  endByte: number\n  showHex: boolean\n  rowSpec: ByteTableRowSpec\n  hex: string[]\n}\n\nexport const ByteTableRow = ({ startByte, endByte, showHex, rowSpec, hex }: ByteTableRowProps) => {\n  const { cells } = rowSpec\n  const getHex = (i: number, j: number): string => hex[_.sumBy(_.take(cells, i), (cell) => cell.width) + j]\n  return (\n    <>\n      <tr>\n        <th className=\"byte-table__byte-header-cell\" rowSpan={showHex ? 3 : 2}>\n          {startByte}-{endByte}\n        </th>\n        {cells.map((cell, i) => (\n          <td\n            key={`byte-table-header-row-${i}`}\n            className={`byte-table__header-cell byte-table__cell-style-${cell.colour} byte-table__border-right`}\n            colSpan={cell.width}\n          >\n            {cell.header ?? <>&nbsp;</>}\n          </td>\n        ))}\n      </tr>\n      {showHex && (\n        <tr>\n          {cells.map((cell, i) =>\n            _.range(cell.width).map((j) => (\n              <td\n                key={`byte-table-hex-row-${i}-${j}`}\n                className={classNames('byte-table__hex-cell', `byte-table__cell-style-${cell.colour}`, {\n                  'byte-table__border-right': j === cell.width - 1,\n                })}\n              >\n                {getHex(i, j)}\n              </td>\n            ))\n          )}\n        </tr>\n      )}\n      <tr className=\"byte-table-row3\">\n        {cells.map((cell, i) =>\n          cell.interpretation?.type === CellInterpretationType.MULTIPLE ? (\n            cell.interpretation.labels.map((label, j) => (\n              <td\n                key={`byte-table-interpretation-${i}-${j}`}\n                className={classNames('byte-table__interpretation-cell', `byte-table__cell-style-${cell.colour}`, {\n                  'byte-table__border-right': j === cell.width - 1,\n                })}\n              >\n                {label}\n              </td>\n            ))\n          ) : (\n            <td\n              key={`byte-table-interpretation-${i}`}\n              className={`byte-table__interpretation-cell byte-table__cell-style-${cell.colour} byte-table__border-right`}\n              colSpan={cell.width}\n            >\n              {cell.interpretation?.label ?? <>&nbsp;</>}\n            </td>\n          )\n        )}\n      </tr>\n    </>\n  )\n}\n","import _ from 'lodash'\nimport { OggPage } from '../audio/OggPage'\nimport { ByteTable } from './ByteTableRow'\nimport {\n  ByteTableRowSpec,\n  ByteTableCellSpec,\n  multipleCellInterpretation,\n  singleCellInterpretation,\n} from './ByteTableRowSpec'\nexport interface OggPageTableProps {\n  page: OggPage\n  showHex: boolean\n}\n\nconst describeHeaderType = (page: OggPage): string => {\n  const parts = []\n  page.containsContinuedPacket && parts.push('Contains continued packet')\n  page.isFirstPage && parts.push('First page')\n  page.isLastPage && parts.push('Last page')\n  return parts.join(', ')\n}\n\nexport const OggPageHeaderTable = ({ page, showHex }: OggPageTableProps) => {\n  const rowSpecs: ByteTableRowSpec[] = [\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          header: 'Capture Pattern',\n          interpretation: multipleCellInterpretation(_.range(4).map((i) => page.capturePattern[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 1,\n          colour: 2,\n          header: 'Version',\n          interpretation: singleCellInterpretation(page.version.toString()),\n        },\n        {\n          width: 1,\n          colour: 3,\n          header: 'Header Type',\n          interpretation: singleCellInterpretation(describeHeaderType(page)),\n        },\n        {\n          width: 2,\n          colour: 4,\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 4,\n          header: 'Granule Position',\n          interpretation: singleCellInterpretation(page.granulePosition.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 4,\n        },\n        {\n          width: 2,\n          colour: 5,\n          header: 'Bitstream Serial Number',\n          interpretation: singleCellInterpretation(page.bitstreamSerialNumber),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 5,\n        },\n        {\n          width: 2,\n          colour: 6,\n          header: 'Page Sequence Number',\n          interpretation: singleCellInterpretation(page.pageSequenceNumber.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 6,\n        },\n        {\n          width: 2,\n          colour: 7,\n          header: 'CRC Checksum',\n          interpretation: singleCellInterpretation(page.crcChecksum),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 7,\n        },\n        {\n          width: 1,\n          colour: 8,\n          header: 'Page Segments',\n          interpretation: singleCellInterpretation(page.numberOfPageSegments.toString()),\n        },\n        ...(page.numberOfPageSegments === 0\n          ? []\n          : [\n              {\n                width: 1,\n                colour: 9,\n                header: 'Segment 1 Size',\n                interpretation: singleCellInterpretation(page.getSegmentSize(0).toString()),\n              } as ByteTableCellSpec,\n            ]),\n      ],\n    },\n    ...getPageSegmentLengthRows(page),\n  ]\n  return <ByteTable dataWindow={page.dataWindow} showHex={showHex} rows={rowSpecs} />\n}\n\nconst getPageSegmentLengthRows = (page: OggPage): ByteTableRowSpec[] =>\n  _.chunk(_.range(1, page.numberOfPageSegments), 4).map((segmentIndices) => ({\n    cells: segmentIndices.map((segmentIndex) => ({\n      width: 1,\n      colour: 9,\n      header: `Segment ${segmentIndex + 1} size`,\n      interpretation: singleCellInterpretation(page.getSegmentSize(segmentIndex).toString()),\n    })),\n  }))\n","import { DataWindow } from '../util/DataWindow'\n\nexport const isOggOpusCommentHeader = (packet: ArrayBuffer): boolean => {\n  if (packet.byteLength < 8) {\n    return false\n  }\n  const magicSignature = new TextDecoder().decode(packet.slice(0, 8))\n  return magicSignature === 'OpusTags'\n}\nexport class OggOpusCommentHeader {\n  constructor(readonly dataWindow: DataWindow) {}\n\n  get magicSignature(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(0, 8))\n  }\n\n  get vendorStringLength(): number {\n    return this.dataWindow.getUint32(8)\n  }\n\n  get vendorString(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(12, this.vendorStringLength))\n  }\n\n  get userCommentListLength(): number {\n    return this.dataWindow.getUint32(12 + this.vendorStringLength)\n  }\n}\n","import { DataWindow } from '../util/DataWindow'\n\nexport const isOggOpusIdentificationHeader = (packet: ArrayBuffer): boolean => {\n  if (packet.byteLength < 8) {\n    return false\n  }\n  const magicSignature = new TextDecoder().decode(packet.slice(0, 8))\n  return magicSignature === 'OpusHead'\n}\n\nexport class OggOpusIdentificationHeader {\n  constructor(readonly dataWindow: DataWindow) {}\n\n  get magicSignature(): string {\n    return new TextDecoder().decode(this.dataWindow.getArrayBufferSlice(0, 8))\n  }\n\n  get version(): number {\n    return this.dataWindow.getUint8(8)\n  }\n\n  get channelCount(): number {\n    return this.dataWindow.getUint8(9)\n  }\n\n  get preSkip(): number {\n    return this.dataWindow.getUint16(10)\n  }\n\n  get inputSampleRate(): number {\n    return this.dataWindow.getUint32(12)\n  }\n\n  get outputGain(): number {\n    return this.dataWindow.getInt16(16)\n  }\n\n  get channelMappingFamily(): number {\n    return this.dataWindow.getUint8(18)\n  }\n}\n","import _ from 'lodash'\nimport { OggOpusCommentHeader } from '../audio/OggOpusCommentHeader'\nimport { ByteTable } from './ByteTableRow'\nimport { ByteTableRowSpec, multipleCellInterpretation, singleCellInterpretation } from './ByteTableRowSpec'\nimport { arrangeCellsIntoRows } from './cellArranger'\n\nexport interface OggOpusCommentHeaderTableProps {\n  header: OggOpusCommentHeader\n  showHex: boolean\n}\n\nexport const OggOpusCommentHeaderTable = ({ header, showHex }: OggOpusCommentHeaderTableProps) => {\n  const rowSpecs: ByteTableRowSpec[] = [\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          header: 'Magic Signature',\n          interpretation: multipleCellInterpretation(_.range(4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          interpretation: multipleCellInterpretation(_.range(4, 4 + 4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    ...arrangeCellsIntoRows(\n      [\n        {\n          width: 4,\n          colour: 2,\n          header: 'Vendor String Length',\n          interpretation: singleCellInterpretation(header.vendorStringLength.toString()),\n        },\n        {\n          width: header.vendorString.length,\n          colour: 3,\n          header: 'Vendor String',\n          interpretation: singleCellInterpretation(header.vendorString),\n        },\n        {\n          width: 4,\n          colour: 4,\n          header: 'User Comment List Length',\n          interpretation: singleCellInterpretation(header.userCommentListLength.toString()),\n        },\n      ],\n      4\n    ),\n  ]\n\n  return <ByteTable dataWindow={header.dataWindow} showHex={showHex} rows={rowSpecs} />\n}\n","import { ByteTableCellSpec, ByteTableRowSpec } from './ByteTableRowSpec'\nimport _ from 'lodash'\n\nexport const arrangeCellsIntoRows = (cells: ByteTableCellSpec[], tableWidth: number): ByteTableRowSpec[] => {\n  const rows: ByteTableRowSpec[] = []\n  const cellsInCurrentRow: ByteTableCellSpec[] = []\n  const spaceUsedInCurrentRow = () => _.sumBy(cellsInCurrentRow, (cell) => cell.width)\n  for (const cell of cells) {\n    const spaceLeftInCurrentRow = tableWidth - spaceUsedInCurrentRow()\n    if (cell.width <= spaceLeftInCurrentRow) {\n      // Can fit in the current row\n      cellsInCurrentRow.push(cell)\n      if (spaceUsedInCurrentRow() === tableWidth) {\n        rows.push({ cells: [...cellsInCurrentRow] })\n        cellsInCurrentRow.length = 0\n      }\n    } else {\n      // Going to have to wrap\n\n      // Initial cell to finish off current row:\n      const initialCell: ByteTableCellSpec = {\n        colour: cell.colour,\n        width: spaceLeftInCurrentRow,\n        header: cell.header,\n        interpretation: cell.interpretation,\n      }\n      cellsInCurrentRow.push(initialCell)\n      rows.push({ cells: [...cellsInCurrentRow] })\n      cellsInCurrentRow.length = 0\n\n      // Full rows:\n      const restWidth = cell.width - initialCell.width\n      const numberOfFullRows = Math.floor(restWidth / tableWidth)\n      const fullRows = _.range(numberOfFullRows).map<ByteTableRowSpec>((_) => ({\n        cells: [\n          {\n            colour: cell.colour,\n            width: tableWidth,\n          },\n        ],\n      }))\n      rows.push(...fullRows)\n\n      // Final cell if needed:\n      const finalCellWidth = restWidth % tableWidth\n      if (finalCellWidth > 0) {\n        const finalCell: ByteTableCellSpec = {\n          colour: cell.colour,\n          width: finalCellWidth,\n        }\n        cellsInCurrentRow.push(finalCell)\n      }\n    }\n  }\n\n  // Add an uncompleted row if needed\n  if (cellsInCurrentRow.length > 0) {\n    rows.push({ cells: [...cellsInCurrentRow] })\n    cellsInCurrentRow.length = 0\n  }\n  return rows\n}\n","import _ from 'lodash'\nimport { OggOpusIdentificationHeader } from '../audio/OggOpusIdentificationHeader'\nimport { ByteTable } from './ByteTableRow'\nimport { ByteTableRowSpec, multipleCellInterpretation, singleCellInterpretation } from './ByteTableRowSpec'\n\nexport interface OggOpusIdentificationHeaderTableProps {\n  header: OggOpusIdentificationHeader\n  showHex: boolean\n}\n\nexport const OggOpusIdentificationHeaderTable = ({ header, showHex }: OggOpusIdentificationHeaderTableProps) => {\n  const rowSpecs: ByteTableRowSpec[] = [\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          header: 'Magic Signature',\n          interpretation: multipleCellInterpretation(_.range(4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 1,\n          interpretation: multipleCellInterpretation(_.range(4, 4 + 4).map((i) => header.magicSignature[i])),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 1,\n          colour: 2,\n          header: 'Version',\n          interpretation: singleCellInterpretation(header.version.toString()),\n        },\n        {\n          width: 1,\n          colour: 3,\n          header: 'Channel Count',\n          interpretation: singleCellInterpretation(header.channelCount.toString()),\n        },\n        {\n          width: 2,\n          colour: 4,\n          header: 'Pre-skip',\n          interpretation: singleCellInterpretation(header.preSkip.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 4,\n          colour: 5,\n          header: 'Input Sample Rate',\n          interpretation: singleCellInterpretation(header.inputSampleRate.toString()),\n        },\n      ],\n    },\n    {\n      cells: [\n        {\n          width: 2,\n          colour: 6,\n          header: 'Output Gain',\n          interpretation: singleCellInterpretation(header.outputGain.toString()),\n        },\n        {\n          width: 1,\n          colour: 7,\n          header: 'Mapping Family',\n          interpretation: singleCellInterpretation(header.channelMappingFamily.toString()),\n        },\n      ],\n    },\n  ]\n  return <ByteTable dataWindow={header.dataWindow} showHex={showHex} rows={rowSpecs} />\n}\n","import React from 'react'\n\nimport './App.scss'\nimport { asHexString } from '../util/hexUtils'\nimport { isOggOpusCommentHeader, OggOpusCommentHeader } from '../audio/OggOpusCommentHeader'\nimport { isOggOpusIdentificationHeader, OggOpusIdentificationHeader } from '../audio/OggOpusIdentificationHeader'\nimport { DataWindow } from '../util/DataWindow'\nimport { OggOpusCommentHeaderTable } from './OggOpusCommentHeaderTable'\nimport { OggOpusIdentificationHeaderTable } from './OggOpusIdentificationHeaderTable'\n\nexport interface OggPacketsListProps {\n  showHex: boolean\n  packets: ArrayBuffer[]\n  isOpus: boolean\n}\n\nconst isUnknownPacket = (packet: ArrayBuffer): boolean =>\n  !isOggOpusIdentificationHeader(packet) && !isOggOpusCommentHeader(packet)\n\nexport const OggPacketsList = ({ packets, showHex, isOpus }: OggPacketsListProps) => (\n  <>\n    {packets.map((packet, i) => (\n      <React.Fragment key={`packet-${i}`}>\n        {isUnknownPacket(packet) && isOpus && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes) - Opus Packet\n            </h3>\n            {showHex && (\n              <div className=\"raw-hex\" key={`packet-hex-${i}`}>\n                {asHexString(packet, true)}\n              </div>\n            )}\n          </>\n        )}\n        {isUnknownPacket(packet) && !isOpus && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes)\n            </h3>\n            {showHex && (\n              <div className=\"raw-hex\" key={`packet-hex-${i}`}>\n                {asHexString(packet, true)}\n              </div>\n            )}\n          </>\n        )}\n        {isOggOpusIdentificationHeader(packet) && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes) - Ogg Opus Identification Header\n            </h3>\n            <p>\n              <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc7845#section-5.1\">\n                RFC 7845 - 5.1. Identification Header\n              </a>\n            </p>\n            <OggOpusIdentificationHeaderTable\n              header={new OggOpusIdentificationHeader(new DataWindow(packet))}\n              showHex={showHex}\n            />\n            <p />\n          </>\n        )}\n        {isOggOpusCommentHeader(packet) && (\n          <>\n            <h3>\n              Packet {i + 1} ({packet.byteLength} bytes) - Ogg Opus Comment Header\n            </h3>\n            <p>\n              <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\">\n                RFC 7845 - 5.2. Comment Header\n              </a>\n            </p>\n            <OggOpusCommentHeaderTable header={new OggOpusCommentHeader(new DataWindow(packet))} showHex={showHex} />\n            <p />\n          </>\n        )}\n      </React.Fragment>\n    ))}\n  </>\n)\n","import { useState } from 'react'\n\nimport './App.scss'\nimport { BitstreamSerialNumber, OggPage } from '../audio/OggPage'\nimport { OggPageHeaderTable } from './OggPageHeaderTable'\nimport _ from 'lodash'\nimport { useShowHexService } from './useShowHexService'\nimport { Option } from '../util/util'\nimport { Bytes } from '../util/types'\nimport { asHexString } from '../util/hexUtils'\nimport { extractPacketsEntirelyContainedWithinPage } from '../audio/packetExtractor'\nimport { OggPacketsList } from './OggPacketsList'\n\nexport interface OggPagesTabProps {\n  readonly oggPages: OggPage[]\n  readonly opusBitstreamSerialNumbers: BitstreamSerialNumber[]\n}\n\nexport const OggPagesTab = ({ oggPages, opusBitstreamSerialNumbers }: OggPagesTabProps) => {\n  const { showHex } = useShowHexService()\n  const [pageNumber, setPageNumber] = useState<number>(0)\n  const [previousOggPages, setPreviousOggPages] = useState<OggPage[]>(oggPages)\n  if (previousOggPages !== oggPages) {\n    setPreviousOggPages(oggPages)\n    setPageNumber(0)\n  }\n  const oggPage = pageNumber < oggPages.length ? oggPages[pageNumber] : undefined\n  const packets = oggPage === undefined ? [] : extractPacketsEntirelyContainedWithinPage(oggPage)\n  return (\n    <div className=\"ogg-pages-tab\">\n      <h1>\n        Ogg Page {pageNumber + 1} / {oggPages.length} ({oggPage?.pageSize ?? 0} bytes)\n      </h1>\n      <button onClick={() => setPageNumber(pageNumber - 1)} disabled={pageNumber === 0}>\n        Previous\n      </button>\n      <button onClick={() => setPageNumber(pageNumber + 1)} disabled={pageNumber >= (oggPages?.length ?? 0) - 1}>\n        Next\n      </button>\n      <h2>Ogg Page Header</h2>\n      {oggPage && (\n        <>\n          <p>\n            <a className=\"rfc-link\" href=\"https://datatracker.ietf.org/doc/html/rfc3533#section-6\">\n              RFC 3533 - 6. The Ogg page format\n            </a>\n          </p>\n          <OggPageHeaderTable page={oggPage} showHex={showHex} />\n          <h2>Ogg Packets</h2>\n          <OggPacketsList\n            packets={packets}\n            showHex={showHex}\n            isOpus={opusBitstreamSerialNumbers.includes(oggPage.bitstreamSerialNumber)}\n          />\n          <h2>Segments</h2>\n          {_.range(0, oggPage.numberOfPageSegments).map((segmentIndex) => (\n            <SegmentInfo\n              key={`segment-${segmentIndex}`}\n              number={segmentIndex + 1}\n              size={oggPage.getSegmentSize(segmentIndex)}\n              hex={showHex ? asHexString(oggPage.getSegment(segmentIndex), true) : undefined}\n            />\n          ))}\n        </>\n      )}\n    </div>\n  )\n}\n\ninterface SegmentInfoProps {\n  number: number\n  size: Bytes\n  hex: Option<string>\n}\n\nconst SegmentInfo = ({ number, size, hex }: SegmentInfoProps) => (\n  <>\n    <h3>\n      Segment {number} ({size} bytes)\n    </h3>\n    {hex && <div className=\"raw-hex\">{hex}</div>}\n  </>\n)\n","import React, { useState } from 'react'\n\nimport './App.scss'\nimport { useShowHexService } from './useShowHexService'\nimport { BitstreamSerialNumber } from '../audio/OggPage'\nimport { detectStreamType } from '../audio/oggParser'\nimport _ from 'lodash'\nimport { OggPacketsList } from './OggPacketsList'\nimport { LogicalBitstream } from '../audio/LogicalBitstream'\n\nexport interface BitstreamsTabProps {\n  streams: LogicalBitstream[]\n  opusBitstreamSerialNumbers: BitstreamSerialNumber[]\n}\n\nexport const BitstreamsTab = ({ streams, opusBitstreamSerialNumbers }: BitstreamsTabProps) => {\n  const { showHex } = useShowHexService()\n  const [previousStreams, setPreviousStreams] = useState<LogicalBitstream[]>(streams)\n  const [selectedStreamSerialNumber, setSelectedStreamSerialNumber] = useState<BitstreamSerialNumber>(\n    streams[0].serialNumber\n  )\n  if (previousStreams !== streams) {\n    setPreviousStreams(streams)\n    setSelectedStreamSerialNumber(streams[0].serialNumber)\n  }\n\n  const stream = streams.find((stream) => stream.serialNumber === selectedStreamSerialNumber)\n  if (stream === undefined) {\n    return <></>\n  }\n  return (\n    <div>\n      <h1>Logical Bitstreams</h1>\n      {streams.map((stream) => (\n        <div key={stream.serialNumber}>\n          <input\n            type=\"radio\"\n            id={stream.serialNumber}\n            name={stream.serialNumber}\n            value={stream.serialNumber}\n            checked={stream.serialNumber === selectedStreamSerialNumber}\n            onChange={() => setSelectedStreamSerialNumber(stream.serialNumber)}\n          />\n          <label htmlFor={stream.serialNumber}>\n            <span className=\"bitstream-serial-number-radio-label\">{stream.serialNumber}</span> -{' '}\n            {detectStreamType(stream)} - {stream.packets.length} packets -{' '}\n            {_.sumBy(stream.packets, (packet) => packet.byteLength)} bytes\n          </label>\n        </div>\n      ))}\n      <h2>Ogg Packets</h2>\n      <OggPacketsList\n        packets={stream.packets}\n        showHex={showHex}\n        isOpus={opusBitstreamSerialNumbers.includes(stream.serialNumber)}\n      />\n    </div>\n  )\n}\n","export const fetchBinaryFile = async (url: string): Promise<ArrayBuffer> => {\n  const response = await fetch(url)\n  const blob = await response.blob()\n  return await blob.arrayBuffer()\n}\n","import { BitstreamSerialNumber } from './OggPage'\nimport { isOggOpusIdentificationHeader } from './OggOpusIdentificationHeader'\n\nexport interface LogicalBitstream {\n  readonly serialNumber: BitstreamSerialNumber\n  readonly packets: ArrayBuffer[]\n}\n\nexport const isBitstreamOpus = (bitstream: LogicalBitstream): boolean =>\n  bitstream.packets.some((packet) => isOggOpusIdentificationHeader(packet))\n","import React from 'react'\n\nimport './App.scss'\nimport { ShowHexServiceProvider } from './useShowHexService'\nimport { Main } from './Main'\n\nexport const App = () => (\n  <ShowHexServiceProvider>\n    <Main />\n  </ShowHexServiceProvider>\n)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { App } from './components/App'\nimport './index.css'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}